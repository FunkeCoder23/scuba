#!/usr/bin/env python2

# SCUBA - Simple Container-Utilizing Build Architecture
# (C) 2015 Jonathon Reinhart
# https://github.com/JonathonReinhart/scuba

import os, os.path
import errno
import sys
import yaml
import subprocess
import shlex
import argparse
from tempfile import NamedTemporaryFile
import atexit
import pipes
import json

__version__ = '1.3.0'

SCUBA_YML = '.scuba.yml'
SCUBA_ROOT = '/scubaroot'
SCUBA_USER = 'scubauser'
SCUBA_GROUP = SCUBA_USER

def appmsg(fmt, *args):
    print 'scuba: ' + fmt.format(*args)


# http://stackoverflow.com/a/9577670
class Loader(yaml.Loader):
    def __init__(self, stream):
        self._root = os.path.split(stream.name)[0]
        super(Loader, self).__init__(stream)

    def from_yaml(self, node):
        '''
        Implementes a !from_yaml constructor with the following syntax:
            !from_yaml filename key

        Arguments:
            filename:   Filename of external YAML document from which to load,
                        relative to the current YAML file.
            key:        Key from external YAML document to return,
                        using a dot-separated syntax for nested keys.

        Examples:
            !from_yaml external.yml pop
            !from_yaml external.yml foo.bar.pop
            !from_yaml "another file.yml" "foo bar.snap crackle.pop"
        '''
        # Load the content from the node, as a scalar
        content = self.construct_scalar(node)

        # Split on unquoted spaces
        parts = shlex.split(content)
        if len(parts) != 2:
            raise yaml.YAMLError('Two arguments expected to !from_yaml')
        filename, key = parts

        # path is relative to the current YAML document
        path = os.path.join(self._root, filename)

        # Load the other YAML document
        with open(path, 'r') as f:
            doc = yaml.load(f, self.__class__)

        # Retrieve the key
        try:
            cur = doc
            for k in key.split('.'):
                cur = cur[k]
        except KeyError:
            raise yaml.YAMLError('Key "{0}" not found in {1}'.format(key, filename))
        return cur

Loader.add_constructor('!from_yaml', Loader.from_yaml)


def find_config():
    '''Search up the diretcory hierarchy for .scuba.yml

    Returns: path, rel on success, or None if not found
        path    The absolute path of the directory where .scuba.yml was found
        rel     The relative path from the directory where .scuba.yml was found
                to the current directory
    '''
    cross_fs = 'SCUBA_DISCOVERY_ACROSS_FILESYSTEM' in os.environ
    path = os.getcwd()

    rel = ''
    while True:
        if os.path.exists(os.path.join(path, SCUBA_YML)):
            return path, rel

        if not cross_fs and os.path.ismount(path):
            appmsg('{0} not found here or any parent up to mount point {1}'.format(SCUBA_YML, path))
            print 'Stopping at filesystem boundary (SCUBA_DISCOVERY_ACROSS_FILESYSTEM not set).'
            sys.exit(128)

        # Traverse up directory hierarchy
        path, rest = os.path.split(path)
        if not rest:
            break

        # Accumulate the relative path back to where we started
        rel = os.path.join(rest, rel)

    appmsg('{0} not found here or any parent directories'.format(SCUBA_YML))
    sys.exit(128)

def load_config(path):
    try:
        with open(path) as f:
            config = yaml.load(f, Loader)
    except IOError as e:
        appmsg('Error opening {0}: {1}', SCUBA_YML, e)
        sys.exit(2)

    required_nodes = ('image',)
    optional_nodes = ('aliases',)

    # Check for missing required nodes
    missing = [n for n in required_nodes if not n in config]
    if missing:
        appmsg('{0}: Required node{1} missing: {2}', SCUBA_YML,
                's' if len(missing) > 1 else '', ', '.join(missing))
        sys.exit(2)

    # Check for unrecognized nodes
    extra = [n for n in config if not n in required_nodes + optional_nodes]
    if extra:
        appmsg('{0}: Unrecognized node{1}: {2}', SCUBA_YML,
                's' if len(extra) > 1 else '', ', '.join(extra))
        sys.exit(2)

    return config

def process_command(config, command):
    aliases = config.get('aliases', {})

    if command:
        rep = aliases.get(command[0])
        if rep:
            command.pop(0)
            command = shlex.split(rep) + command

    return command


def make_vol_opt(hostdir, contdir, options=None):
    '''Generate a docker volume option'''
    vol = '--volume={0}:{1}'.format(hostdir, contdir)
    if options != None:
        if isinstance(options, basestring):
            options = (options,)
        vol += ':' + ','.join(options)
    return vol

def passwd_entry(**kw):
    return '{username}:{password}:{uid}:{gid}:{gecos}:{homedir}:{shell}'.format(**kw)

def group_entry(groupname, password, gid, users=[]):
    return '{groupname}:{password}:{gid}:{users}'.format(
            groupname = groupname,
            password = password,
            gid = gid,
            users = ','.join(users))

def shell_quote(s):
    # http://stackoverflow.com/a/847800/119527
    return pipes.quote(s)

def get_image_command(image):
    '''Gets the default command for an image'''
    args = ['docker', 'inspect', image]
    try:
        p = subprocess.Popen(args, stdout = subprocess.PIPE)
    except OSError as e:
        if e.errno == errno.ENOENT:
            appmsg('Failed to execute docker. Is it installed?')
            sys.exit(2)
    
    stdout, _ = p.communicate()
    if not p.returncode == 0:
        appmsg('Failed to inspect image')
        sys.exit(2)

    info = json.loads(stdout)[0]
    return info['Config']['Cmd']

def get_umask():
    # Same logic as bash/builtins/umask.def
    val = os.umask(022)
    os.umask(val)
    return val 

def generate_scubainit(config, command):
    '''Generate a .scubainit script

    This script is executed by /bin/sh, as passed to "docker run".
    It is responsible for setting up the environment, and running the
    user-specified command. Normally, if the user provides no command to
    "docker run", the image's default CMD is run. Because we force
    "/bin/sh .scubainit" to be run, scuba must emulate the default behavior
    itself.
    '''
    if len(command) == 0:
        # No user-provided command; we want to run the image's default command
        command = get_image_command(config['image'])

    # Turn command into a string which you would enter in a shell
    command = ' '.join(shell_quote(c) for c in command)

    # Open a temporary file
    with NamedTemporaryFile(prefix='scubainit', delete=False) as f:
        # Delete this file when scuba exits
        atexit.register(os.remove, f.name)

        def write_cmd(*args):
            f.write(' '.join(c for c in args) + '\n')

        write_cmd('#!/bin/sh')

        # Add scubauser with current uid/gid
        # BusyBox only has 'adduser', with arguments incompatible with
        # that of the standard 'useradd'.
        # Instead, we'll just write the entry ourselves.
        entry = passwd_entry(
            username = SCUBA_USER,
            password = 'x',
            uid = os.getuid(),
            gid = os.getgid(),
            gecos = 'Scuba User',
            homedir = '/',          # Docker sets $HOME=/
            shell = '/bin/sh',
            )
        write_cmd('echo', shell_quote(entry), '>>', '/etc/passwd')

        # Add scubauser group
        entry = group_entry(
            groupname = SCUBA_GROUP,
            password = 'x',
            gid = os.getgid(),
            users = [SCUBA_USER],
            )
        write_cmd('echo', shell_quote(entry), '>>', '/etc/group')

        # Set the umask
        write_cmd('umask', oct(get_umask()))

        # Execute the command indicated by the user, as the scuba user
        write_cmd('su', SCUBA_USER, '-c', shell_quote(command))

        return f.name

def parse_args():
    ap = argparse.ArgumentParser(description='Simple Container-Utilizing Build Apparatus')
    ap.add_argument('-v', '--version', action='version', version='%(prog)s ' + __version__)
    ap.add_argument('command', nargs=argparse.REMAINDER)
    args = ap.parse_args()

    return args

def main():
    args = parse_args()

    # top_path is where .scuba.yml is found, and becomes the top of our bind mount.
    # top_rel is the relative path from top_path to the current working directory,
    # and is where we'll set the working directory in the container (relative to
    # the bind mount point).
    top_path, top_rel = find_config()

    config = load_config(os.path.join(top_path, SCUBA_YML))

    # Process any aliases
    usercmd = process_command(config, args.command)

    # Determine if Docker is running locally or remotely
    if 'DOCKER_HOST' in os.environ:
        '''
        Docker is running remotely (e.g. boot2docker on OSX).
        We don't need to do any user setup whatsoever.

        TODO: For now, remote instances won't have any .scubainit

        See:
        https://github.com/JonathonReinhart/scuba/issues/17
        '''
        docker_opts = []
        docker_cmd = usercmd
        vol_opts = None

    else:
        '''
        Docker is running natively (e.g. on Linux).

        We want files created inside the container (in scubaroot) to appear to the
        host as if they were created there (owned by the same uid/gid, with same
        umask, etc.) So, we use a .scubainit script to create a user with the same
        uid/gid, su(1) to that user, and run the usercommand.
        '''
        # Generate a .scubainit script
        scubainit_path = generate_scubainit(config, usercmd)

        # Mount scubainit script
        docker_opts = [make_vol_opt(scubainit_path, '/.scubainit', 'z')]

        # Run the .scubainit at startup
        docker_cmd = ['/bin/sh', '/.scubainit']

        # NOTE: This tells Docker to re-label the directory for compatibility
        # with SELinux. See `man docker-run` for more information.
        vol_opts = ['z']


    # Build the docker command line
    run_args = ['docker', 'run',
        # interactive: keep STDIN open
        '-i',

        # allocate TTY
        '-t',

        # remove container after exit
        '--rm',

        # Mount scuba root directory...
        make_vol_opt(top_path, SCUBA_ROOT, vol_opts),

        # ...and set the working dir relative to it
        '-w', os.path.join(SCUBA_ROOT, top_rel),
    ] + docker_opts

    # Docker image
    run_args.append(config['image'])

    # Command to run in container
    run_args += docker_cmd

    #from pprint import pprint; pprint(run_args)
    #sys.exit(42)

    try:
        rc = subprocess.call(run_args)
    except OSError as e:
        if e.errno == errno.ENOENT:
            appmsg('Failed to execute docker. Is it installed?')
            sys.exit(2)

    sys.exit(rc)

if __name__ == '__main__':
    main()
